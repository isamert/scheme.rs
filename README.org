* scheme.rs
/scheme.rs/ is a simple Scheme interpreter that implements considerably large
subset of R5RS with some extensions from R7RS. No dependencies to any other
Rust packages.

** Motivation
I was studying about compilers and interpreters. On the other hand I was
trying to learn Rust. So I combined those two and this project has emerged.
There are thousands of fast, mature and feature-rich Scheme interpreters that
you can use. This project is not intended to be usable in production altough
I use it for my personal scripts and one can embed /scheme.rs/ into ones
project to provide scripting facilities.

** Examples
#+BEGIN_SRC scheme
;; FizzBuzz
(define (fizzbuzz x y)
  (println
    (cond ((= (modulo x 15) 0 ) "FizzBuzz")
          ((= (modulo x 3) 0 ) "Fizz")
          ((= (modulo x 5) 0 ) "Buzz")
          (else x)))

    (if (< x y) (fizzbuzz (+ x 1) y)))

(fizzbuzz 1 100)


;; Read a line from file and print it
(call-with-input-file "file.txt"
  (λ (file)
    (println (read-line file))))

;; Tail recursive fibanocci
(define (fib n)
  (define (fib-helper a b n)
    (if (= n 0) a
        (fib-helper b (+ a b) (- n 1))))

  (fib-helper 0 1 n))

(display (fib 60)) ; prints 1548008755920
#+END_SRC

** List of functions
Most of these functions are implemented in Rust.

| define                | <                         | procedure?    | char<=?        |
| set!                  | >                         | boolean?      | char>=?        |
| λ                     | <=                        | char?         | char-ci=?      |
| lambda                | >=                        | string?       | char-ci<?      |
| apply                 | =                         | integer?      | char-ci>?      |
| let                   | cond                      | exact?        | char-ci<=?     |
| let*                  | case                      | inexact?      | char-ci>=?     |
| letrec                | and                       | number?       | string=?       |
| quote                 | or                        | pair?         | string<?       |
| quasiquote            | cons                      | list?         | string>?       |
| unquote               | car                       | output-port?  | string<=?      |
| eqv?                  | cdr                       | input-port?   | string>=?      |
| eq?                   | append                    | textual-port? | string-ci=?    |
| equal?                | list-copy                 | binary-port?  | string-ci<?    |
| +                     | string-append             | not           | string-ci>?    |
| -                     | string-upcase             | zero?         | string-ci<=?   |
| *                     | string-downcase           | positive?     | string-ci>=?   |
| /                     | string-length             | negative?     | substring      |
| remainder             | char-upcase               | odd?          | string-ref     |
| modulo                | char-downcase             | even?         | string         |
| numerator             | char-upper-case?          | abs           | symbol->string |
| denominator           | char-lower-case?          | gcd           | string->symbol |
| sqrt                  | char-alphabetic?          | lcm           | string->list   |
| expt                  | char-numeric?             | 1+            | list->string   |
| ceiling               | char-alphanumeric?        | 1-            | char->integer  |
| floor                 | char-whitespace?          | list          | integer->char  |
| truncate              | string-copy               | list-ref      |                |
| round                 | string-append             | null?         |                |
| exp                   | load                      | sum           |                |
| log                   | file-exists?              | product       |                |
| sin                   | delete-file               | map           |                |
| cos                   | system*                   | filter        |                |
| tan                   | get-environment-variable  | reverse       |                |
| asin                  | get-environment-variables | length        |                |
| acos                  | open-binary-input-file    | max           |                |
| atan                  | open-binary-output-file   | min           |                |
| number->string        | open-input-file           | list-tail     |                |
| string->number        | open-output-file          | list-head     |                |
| id                    | read                      | list-ref      |                |
| curry                 | read-u8                   | memq          |                |
| foldr                 | read-line                 | memv          |                |
| foldl                 | read-char                 | member        |                |
| unfold                | read-all                  | assq          |                |
| reduce                | write                     | assv          |                |
| call-with-input-file  | display                   | assoc         |                |
| call-with-output-file | newline                   | char=?        |                |
| println               | write-string              | char<?        |                |
| compose               | close-port                | char>?        |                |

** Notes about implementation
*** What is not included?
- Functions that provide mutability
- Hygienic macros (I may implement this in the future)
- call-with-current-continuation and it's derivatives
    - I don't of if it's possible to implement these functions only by using
      Rust's stack.

*** Proper tail recursion
Tail calls are optimized but this implementation does not reflect the
standard fully. Because there are no macros, functions like ~and~, ~or~,
~cond~, ~let~ etc. are implemented as seperate procedures. So a procedure with
~and~ in it's tail call may blow up the stack. Regardless of macro
implementation, I may fix this in the future simply by expanding required
functions before evaluation.
